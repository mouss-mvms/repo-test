require 'rails_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to specify the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is gene^rated by the rails scaffold
# generator.  If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails.  There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.
#
# Compared to earlier versions of this generator, there is very limited use of
# stubs and message expectations in this spec.  Stubs are only used when there
# is no simpler way to get a handle on the object needed for the example.
# Message expectations are only used when there is no simpler way to specify
# that an instance is receiving a specific message.

RSpec.describe Api::Shops::ProductsController, type: :controller do

  # GET #index
  describe "GET #index" do
    before(:each) do
      @products = [create(:product), create(:product), create(:product)]
      @shop = create(:shop)
      @products.each { |prod| prod.update(shop_id: @shop.id) }
    end

    context "with valid params" do
      it "get all products from shop" do
        get :index, params: { shop_id: @shop.id }
        should respond_with(200)

        response_body = JSON.parse(response.body)
        expect(response_body).to be_an_instance_of(Array)
        expect(response_body.count).to eq(3)

        product_ids = response_body.map { |p| p.symbolize_keys[:id] }
        expect(Product.where(id: product_ids).actives.to_a).to eq(@products)
      end
    end

    context "with invalid params" do
      context "shop_id not a Numeric" do
        it "should returns 400 HTTP Status" do
          get :index, params: { shop_id: 'Xenomorph' }
          should respond_with(400)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Shop_id is incorrect", "message"=>"Bad Request", "status"=>400})
        end
      end

      context "shop doesn't exists" do
        it "should returns 404 HTTP Status" do
          get :index, params: { shop_id: (@shop.id + 1) }
          should respond_with(404)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Couldn't find Shop with 'id'=#{@shop.id + 1}", "message"=>"Not Found", "status"=>404})
        end
      end
    end
  end

  # GET #show
  describe "GET #show" do
    before(:each) do
      @product = create(:product)
      @shop = create(:shop)
      @product.update(shop_id: @shop.id)
    end

    context "with valid params" do
      it "get all products from shop" do
        get :show, params: { shop_id: @shop.id, id: @product.id }
        should respond_with(200)

        expect(response.body).to eq(Dto::Product::Response.create(@product).to_h.to_json)
      end
    end

    context "with invalid params" do
      context "shop_id not a Numeric" do
        it "should returns 400 HTTP Status" do
          get :show, params: { shop_id: 'Kowabunga', id: @product.id }
          should respond_with(400)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Shop_id is incorrect", "message"=>"Bad Request", "status"=>400})
        end
      end

      context "id not a Numeric" do
        it "should returns 400 HTTP Status" do
          get :show, params: { shop_id: @shop.id, id: '§§' }
          should respond_with(400)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Id is incorrect", "message"=>"Bad Request", "status"=>400})
        end
      end

      context "shop doesn't exists" do
        it "should returns 404 HTTP Status" do
          get :show, params: { shop_id: (@shop.id + 1), id: @product.id }
          should respond_with(404)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Couldn't find Shop with 'id'=#{@shop.id + 1}", "message"=>"Not Found", "status"=>404})
        end
      end

      context "product doesn't exists" do
        it "should returns 404 HTTP Status" do
          post :show, params: { shop_id: @product.shop_id, id: (@product.id + 1) }
          should respond_with(404)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Couldn't find Product with 'id'=#{@product.id + 1}", "message"=>"Not Found", "status"=>404})
        end
      end
    end
  end

  # POST #create
  describe "POST #create" do
    before(:each) do
      @shop = create(:shop)
      @category = create(:category_for_product)
      @create_params = {
        name: "manteau MAC",
        slug: "manteau-mac",
        categoryId: @category.id,
        brand: "3sixteen",
        status: "online",
        isService: true,
        sellerAdvice: "pouet",
        description: "Manteau type Macintosh en tissu 100% coton déperlant sans traitement. Les fibres de coton à fibres extra longues (ELS) sont tissées de manière incroyablement dense - rien de plus. Les fibres ELS sont difficiles à trouver - seulement 2% du coton mondial peut fournir des fibres qui répondent à cette norme.Lorsque le tissu est mouillé, ces fils se dilatent et créent une barrière impénétrable contre l'eau. Le tissu à la sensation au touché, le drapé et la respirabilité du coton avec les propriétés techniques d'un tissu synthétique. Le manteau est doté d'une demi-doublure à imprimé floral réalisée au tampon à la main dans la plus pure tradition indienne.2 coloris: TAN ou BLACK",
        variants: [
          {
            basePrice: 379,
            weight: 1,
            quantity: 0,
            imageUrls: ['https://www.eklecty-city.fr/wp-content/uploads/2018/07/robocop-paul-verhoeven-banner.jpg'],
            isDefault: false,
            goodDeal: {
              startAt: "17/05/2021",
              endAt: "18/06/2021",
              discount: 20
            },
            characteristics: [
              {
                value: "coloris black",
                name: "color"
              },
              {
                value: "S",
                name: "size"
              }
            ]
          }
        ]
      }
    end

    context "with valid params" do
      context "user is admin" do
        let(:admin_user) { create(:admin_user) }
        it "creates a product" do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(admin_user)
          post :create, params: @create_params.merge(shop_id: @shop.id)
          should respond_with(201)
          expect(response.body).to eq(Dto::Product::Response.create(Product.first).to_h.to_json)
        end
      end
      context "user is owner of shop" do
        let(:shop_employee_user) { create(:shop_employee_user) }
        it "creates a product" do
          @shop.owner = shop_employee_user.shop_employee
          @shop.save
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(shop_employee_user)
          post :create, params: @create_params.merge(shop_id: @shop.id)
          should respond_with(201)
          expect(response.body).to eq(Dto::Product::Response.create(Product.first).to_h.to_json)
        end
      end
    end

    context "with invalid params" do
      context 'x-client-id is missing' do
        it 'should return 40& HTTP status' do
          post :create, params: @create_params.merge(shop_id: @shop.id)
          should respond_with(401)
        end
      end

      context 'User is not found' do
        let(:user) { create(:user) }
        it 'should return 403 HTTP status' do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(user)
          post :create, params: @create_params.merge(shop_id: @shop.id)
          should respond_with(403)
        end
      end

      context 'User is not an admin' do
        let(:user) { create(:user) }
        it 'should return 403 HTTP status' do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(user)
          post :create, params: @create_params.merge(shop_id: @shop.id)
          should respond_with(403)
        end
      end

      context 'User is a customer' do
        let(:customer_user) { create(:customer_user) }
        it 'should return 403 HTTP status' do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(customer_user)
          post :create, params: @create_params.merge(shop_id: @shop.id)
          should respond_with(403)
        end
      end

      context 'User is a shop_employee but the owner' do
        let(:shop_employee_user) { create(:shop_employee_user) }
        it 'should return 403 HTTP status' do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(shop_employee_user)
          post :create, params: @create_params.merge(shop_id: @shop.id)
          should respond_with(403)
        end
      end

      context 'Shop Id is not a Numeric' do
        let(:admin_user) { create(:admin_user) }
        it "should returns 400 Bad Request" do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(admin_user)
          post :create, params: @create_params.merge(shop_id: "ErenJäger")
          should respond_with(400)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Shop_id is incorrect", "message"=>"Bad Request", "status"=>400})
        end
      end

      context "Category doesn't exists" do
        let(:admin_user) { create(:admin_user) }
        it "should returns 404 Not Found" do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(admin_user)
          @create_params[:categoryId] += 1
          post :create, params: @create_params.merge(shop_id: @shop.id)
          should respond_with(404)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Couldn't find Category with 'id'=#{@create_params[:categoryId]}", "message"=>"Not Found", "status"=>404})
        end
      end

      context 'Name is not a present' do
        let(:admin_user) { create(:admin_user) }
        it "Returns 400 Bad Request" do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(admin_user)
          @create_params.delete(:name)
          post :create, params: @create_params.merge(shop_id: @shop.id)
          should respond_with(400)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Name is incorrect", "message"=>"Bad Request", "status"=>400})
        end
      end

      context 'Name is blank' do
        let(:admin_user) { create(:admin_user) }
        it "Returns 400 Bad Request" do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(admin_user)
          @create_params[:name] = ""
          post :create, params: @create_params.merge(shop_id: @shop.id)
          should respond_with(400)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Name is incorrect", "message"=>"Bad Request", "status"=>400})
        end
      end
    end
  end

  # POST #create_offline
  describe "POST #create_offline" do
    before(:each) do
      @shop = create(:shop)
      @category = create(:category_for_product)
      @create_params = {
        name: "manteau MAC",
        slug: "manteau-mac",
        categoryId: @category.id,
        brand: "3sixteen",
        status: "online",
        isService: true,
        sellerAdvice: "pouet",
        description: "Manteau type Macintosh en tissu 100% coton déperlant sans traitement. Les fibres de coton à fibres extra longues (ELS) sont tissées de manière incroyablement dense - rien de plus. Les fibres ELS sont difficiles à trouver - seulement 2% du coton mondial peut fournir des fibres qui répondent à cette norme.Lorsque le tissu est mouillé, ces fils se dilatent et créent une barrière impénétrable contre l'eau. Le tissu à la sensation au touché, le drapé et la respirabilité du coton avec les propriétés techniques d'un tissu synthétique. Le manteau est doté d'une demi-doublure à imprimé floral réalisée au tampon à la main dans la plus pure tradition indienne.2 coloris: TAN ou BLACK",
        variants: [
          {
            basePrice: 379,
            weight: 1,
            quantity: 0,
            isDefault: false,
            goodDeal: {
              startAt: "17/05/2021",
              endAt: "18/06/2021",
              discount: 20
            },
            characteristics: [
              {
                value: "coloris black",
                name: "color"
              },
              {
                value: "S",
                name: "size"
              }
            ]
          }
        ]
      }
    end

    context "with valid params" do
      it "creates a product" do
        post :create_offline, params: @create_params.merge(shop_id: @shop.id)
        should respond_with(201)
        expect(response.body).to eq(Dto::Product::Response.create(Product.first).to_h.to_json)
      end
    end

    context "with invalid params" do
      context "shop_id not a Numeric" do
        it "should returns 400 HTTP Status" do
          post :create_offline, params: @create_params.merge(shop_id: "ErenJäger")
          should respond_with(400)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Shop_id is incorrect", "message"=>"Bad Request", "status"=>400})
        end
      end

      context "category doesn't exists" do
        it "should returns 404 HTTP Status" do
          @create_params[:categoryId] += 1
          post :create_offline, params: @create_params.merge(shop_id: @shop.id)
          should respond_with(404)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Couldn't find Category with 'id'=#{@create_params[:categoryId]}", "message"=>"Not Found", "status"=>404})
        end
      end

      context "name is not a present" do
        it "should returns 400 HTTP Status" do
          @create_params.delete(:name)
          post :create_offline, params: @create_params.merge(shop_id: @shop.id)
          should respond_with(400)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Name is incorrect", "message"=>"Bad Request", "status"=>400})
        end
      end

      context "name is blank" do
        it "should returns 400 HTTP Status" do
          @create_params[:name] = ""
          post :create_offline, params: @create_params.merge(shop_id: @shop.id)
          should respond_with(400)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Name is incorrect", "message"=>"Bad Request", "status"=>400})
        end
      end
    end
  end

  # PUT #update
  describe "PUT #update" do
    before(:each) do
      @product = create(:product_with_category)
      @update_params = {
        name: "Lot de 4 tasses à café style rétro AOC",
        categoryId: @product.category_id,
        brand: "AOC",
        status: "online",
        isService: false,
        sellerAdvice: "Les tasses donneront du style à votre pause café !",
        description: "Lot de 4 tasses à café rétro chic en porcelaine. 4 tasses et 4 sous-tasses de 4 couleurs différentes.",
        variants: [
          {
            basePrice: 19.9,
            weight: 0.24,
            quantity: 4,
            imageUrls: ['https://www.eklecty-city.fr/wp-content/uploads/2018/07/robocop-paul-verhoeven-banner.jpg'],
            isDefault: true,
            goodDeal: {
              startAt: "17/05/2021",
              endAt: "18/06/2021",
              discount: 20
            },
            characteristics: [
              {
                value: "coloris black",
                name: "color"
              },
              {
                value: "S",
                name: "size"
              }
            ]
          }
        ]
      }
    end

    context "with valid params" do
      context "User is admin" do
        let(:admin_user) { create(:admin_user) }
        it "Updates a product" do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(admin_user)
          put :update, params: @update_params.merge(shop_id: @product.shop_id, id: @product.id)
          should respond_with(200)
          expect(response.body).to eq(Dto::Product::Response.create(Product.first).to_h.to_json)
        end
      end
    end

    context "with invalid url" do
      let(:admin_user) { create(:admin_user) }
      context "shop_id not a Numeric" do
        it "should returns 400 HTTP Status" do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(admin_user)
          put :update, params: @update_params.merge(shop_id: 'ChuckNorris', id: @product.id)
          should respond_with(400)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Shop_id is incorrect", "message"=>"Bad Request", "status"=>400})
        end
      end

      context "id not a Numeric" do
        it "should returns 400 HTTP Status" do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(admin_user)
          put :update, params: @update_params.merge(shop_id: @product.shop_id, id: 'Terminator')
          should respond_with(400)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Id is incorrect", "message"=>"Bad Request", "status"=>400})
        end
      end
    end

    context "with invalid params" do
      context 'x-client-id is missing' do
        it 'should return 401 HTTP status' do
          put :update, params: { shop_id: @product.shop_id, id: @product.id }
          should respond_with(401)
        end
      end

      context 'User is not an admin' do
        let(:user) { create(:user) }
        it 'should return 403 HTTP status' do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(user)

          put :update, params: @update_params.merge(shop_id: @product.shop_id, id: @product.id)
          should respond_with(403)
        end
      end

      context 'User is a customer' do
        let(:customer_user) { create(:customer_user) }
        it 'should return 403 HTTP status' do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(customer_user)
          put :update, params: @update_params.merge(shop_id: @product.shop_id, id: @product.id)
          should respond_with(403)
        end
      end

      context 'User is a shop_employee but the owner' do
        let(:shop_employee_user) { create(:shop_employee_user) }
        it 'should return 403 HTTP status' do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(shop_employee_user)
          put :update, params: @update_params.merge(shop_id: @product.shop_id, id: @product.id)
          should respond_with(403)
        end
      end

      context "No params" do
        let(:admin_user) { create(:admin_user) }
        it "should returns 400 HTTP status" do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(admin_user)
          put :update, params: { shop_id: @product.shop_id, id: @product.id }
          should respond_with(400)
        end
      end

      context "Category doesn't exists" do
        let(:admin_user) { create(:admin_user) }
        it "should returns 404 HTTP status" do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(admin_user)
          @update_params[:categoryId] = 1
          put :update, params: @update_params.merge(locale: I18n.locale, shop_id: @product.shop_id, id: @product.id)
          should respond_with(404)
        end
      end

      context "Product doesn't exists" do
        let(:admin_user) { create(:admin_user) }
        it "should returns 404 HTTP status" do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(admin_user)
          put :update, params: @update_params.merge(locale: I18n.locale, shop_id: @product.shop_id, id: (@product.id + 1))
          should respond_with(404)
        end
      end
    end
  end

  # POST #update_offline
  describe "PUT #update_offline" do
    before(:each) do
      @product = create(:product_with_category)
      @update_params = {
        name: "Lot de 4 tasses à café style rétro AOC",
        categoryId: @product.category_id,
        brand: "AOC",
        status: "online",
        isService: false,
        sellerAdvice: "Les tasses donneront du style à votre pause café !",
        description: "Lot de 4 tasses à café rétro chic en porcelaine. 4 tasses et 4 sous-tasses de 4 couleurs différentes.",
        variants: [
          {
            basePrice: 19.9,
            weight: 0.24,
            quantity: 4,
            isDefault: true,
            goodDeal: {
              startAt: "17/05/2021",
              endAt: "18/06/2021",
              discount: 20
            },
            characteristics: [
              {
                value: "coloris black",
                name: "color"
              },
              {
                value: "S",
                name: "size"
              }
            ]
          }
        ]
      }
    end

    context "with valid params" do
      it "Updates a product" do
        put :update_offline, params: @update_params.merge(shop_id: @product.shop_id, id: @product.id)
        should respond_with(200)
        expect(response.body).to eq(Dto::Product::Response.create(@product.reload).to_h.to_json)
      end
    end

    context "with invalid url" do
      context "shop_id not a Numeric" do
        it "should returns 400 HTTP Status" do
          put :update_offline, params: @update_params.merge(shop_id: 'ChuckNorris', id: @product.id)
          should respond_with(400)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Shop_id is incorrect", "message"=>"Bad Request", "status"=>400})
        end
      end

      context "id not a Numeric" do
        it "should returns 400 HTTP Status" do
          put :update_offline, params: @update_params.merge(shop_id: @product.shop_id, id: 'Terminator')
          should respond_with(400)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Id is incorrect", "message"=>"Bad Request", "status"=>400})
        end
      end

    end

    context "with invalid params" do
      context "no params" do
        it "should returns 400 HTTP Status" do
          put :update_offline, params: { shop_id: @product.shop_id, id: @product.id }
          should respond_with(400)
        end
      end

      context "Category doesn't exists" do
        it "should returns 404 HTTP Status" do
          @update_params[:categoryId] = 1
          put :update_offline, params: @update_params.merge(shop_id: @product.shop_id, id: @product.id)
          should respond_with(404)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Couldn't find Category with 'id'=#{@update_params[:categoryId]}", "message"=>"Not Found", "status"=>404})
        end
      end

      context "product doesn't exists" do
        it "should returns 404 HTTP Status" do
          put :update_offline, params: @update_params.merge(shop_id: @product.shop_id, id: (@product.id + 1))
          should respond_with(404)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Couldn't find Product with 'id'=#{@product.id + 1}", "message"=>"Not Found", "status"=>404})
        end
      end

    end
  end

  # DELETE #destroy
  describe "DELETE #destroy" do
    before(:each) do
      @product = create(:product)
      @shop = create(:shop)
      @product.update(shop_id: @shop.id)
    end

    context "with valid params" do
      let(:admin_user) { create(:admin_user) }

      it "deletes a product" do
        request.headers['HTTP_X_CLIENT_ID'] = generate_token(admin_user)
        expect(Product.count).to eq(1)
        delete :destroy, params: { shop_id: @shop.id, id: @product.id }
        should respond_with(204)

        expect(Product.count).to be_zero
      end
    end

    context "with invalid params" do
      context 'x-client-id is missing' do
        it 'should return 401 HTTP status' do
          delete :destroy, params: { shop_id: @shop.id, id: @product.id }
          should respond_with(401)
        end
      end

      context 'User is not an admin' do
        let(:user) { create(:user) }
        it 'should return 403 HTTP status' do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(user)
          delete :destroy, params: { shop_id: @shop.id, id: @product.id }
          should respond_with(403)
        end
      end

      context 'User is a customer' do
        let(:customer_user) { create(:customer_user) }
        it 'should return 403 HTTP status' do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(customer_user)
          delete :destroy, params: { shop_id: @shop.id, id: @product.id }

          should respond_with(403)
        end
      end

      context 'User is a shop_employee but the owner' do
        let(:shop_employee_user) { create(:shop_employee_user) }
        it 'should return 403 HTTP status' do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(shop_employee_user)
          delete :destroy, params: { shop_id: @shop.id, id: @product.id }

          should respond_with(403)
        end
      end

      context "Shop_id not a Numeric" do
        let(:admin_user) { create(:admin_user) }

        it "should returns 400 Bad Request" do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(admin_user)
          delete :destroy, params: { shop_id: 'Kowabunga', id: @product.id }
          should respond_with(400)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Shop_id is incorrect", "message"=>"Bad Request", "status"=>400})
        end
      end

      context 'Id not a Numeric' do
        let(:admin_user) { create(:admin_user) }

        it "should returns 400 HTTP Status" do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(admin_user)
          delete :destroy, params: { shop_id: @shop.id, id: '§§' }
          should respond_with(400)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Id is incorrect", "message"=>"Bad Request", "status"=>400})
        end
      end

      context "Shop doesn't exists" do
        let(:admin_user) { create(:admin_user) }

        it "should returns 404 HTTP Status" do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(admin_user)
          delete :destroy, params: { shop_id: (@shop.id + 1), id: @product.id }
          should respond_with(404)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Couldn't find Shop with 'id'=#{@shop.id + 1}", "message"=>"Not Found", "status"=>404})
        end
      end

      context "Product doesn't exists" do
        let(:admin_user) { create(:admin_user) }

        it "should returns 404 HTTP Status" do
          request.headers['HTTP_X_CLIENT_ID'] = generate_token(admin_user)
          delete :destroy, params: { shop_id: @product.shop_id, id: (@product.id + 1) }
          should respond_with(404)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Couldn't find Product with 'id'=#{@product.id + 1}", "message"=>"Not Found", "status"=>404})
        end
      end
    end
  end

  # DELETE #destroy_offline
  describe "DELETE #destroy_offline" do
    before(:each) do
      @product = create(:product)
      @shop = create(:shop)
      @product.update(shop_id: @shop.id)
    end

    context "with valid params" do
      it "deletes a product" do
        expect(Product.count).to eq(1)
        delete :destroy_offline, params: { shop_id: @shop.id, id: @product.id }
        should respond_with(204)

        expect(Product.count).to be_zero
      end
    end

    context "with invalid params" do
      context "shop_id not a Numeric" do
        it "should returns 400 HTTP Status" do
          delete :destroy_offline, params: { shop_id: 'Kowabunga', id: @product.id }
          should respond_with(400)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Shop_id is incorrect", "message"=>"Bad Request", "status"=>400})
        end
      end

      context "id not a Numeric" do
        it "should returns 400 HTTP Status" do
          delete :destroy_offline, params: { shop_id: @shop.id, id: '§§' }
          should respond_with(400)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Id is incorrect", "message"=>"Bad Request", "status"=>400})
        end
      end

      context "shop doesn't exists" do
        it "should returns 404 HTTP Status" do
          delete :destroy_offline, params: { shop_id: (@shop.id + 1), id: @product.id }
          should respond_with(404)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Couldn't find Shop with 'id'=#{@shop.id + 1}", "message"=>"Not Found", "status"=>404})
        end
      end

      context "product doesn't exists" do
        it "should returns 404 HTTP Status" do
          delete :destroy_offline, params: { shop_id: @product.shop_id, id: (@product.id + 1) }
          should respond_with(404)
          expect(JSON.parse(response.body)).to eq({"detail"=>"Couldn't find Product with 'id'=#{@product.id + 1}", "message"=>"Not Found", "status"=>404})
        end
      end
    end
  end
end

def generate_token(user)
  exp_payload = { id: user.id, exp: Time.now.to_i + 1 * 3600 * 24 }
  JWT.encode exp_payload, ENV["JWT_SECRET"], 'HS256'
end



